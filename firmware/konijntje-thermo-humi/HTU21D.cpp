/*
 HTU21D Humidity Sensor Library
 By: Nathan Seidle
 SparkFun Electronics
 Date: September 22nd, 2013
 License: This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).

 This library allows an Arduino to read from the HTU21D low-cost high-precision humidity sensor.

 If you have feature suggestions or need support please use the github support page: https://github.com/sparkfun/HTU21D

 Hardware Setup: The HTU21D lives on the I2C bus. Attach the SDA pin to A4, SCL to A5. If you are using the SparkFun
 breakout board you *do not* need 4.7k pull-up resistors on the bus (they are built-in).

 Link to the breakout board product:

 Software:
 Call HTU21D.Begin() in setup.
 HTU21D.ReadHumidity() will return a float containing the humidity. Ex: 54.7
 HTU21D.ReadTemperature() will return a float containing the temperature in Celsius. Ex: 24.1
 HTU21D.SetResolution(byte: 0b.76543210) sets the resolution of the readings.
 HTU21D.check_crc(message, check_value) verifies the 8-bit CRC generated by the sensor
 HTU21D.read_user_register() returns the user register. Used to set resolution.

 Changes made by Christoph Tack, 2014:
 * use of interface for I2C

 sensor datasheet can be found at: http://www.silabs.com/Support%20Documents/TechnicalDocs/Si7021.pdf
 */

#include "HTU21D.h"

HTU21D::HTU21D(I2cInterface *pI2C):_pI2c(pI2C)
{
    //Set initial values for private vars
}

bool HTU21D::setHeater(bool bHeaterOn){
    byte userRegister;
    if(!readReg(READ_USER_REG, &userRegister,1)){
        return false;
    }
    if(bHeaterOn){
        bitSet(userRegister,HTRE_BIT);
    }else{
        bitClear(userRegister, HTRE_BIT);
    }
    return writeCmd(WRITE_USER_REG, &userRegister,1);
}

bool HTU21D::readHumidity(float& humidity, bool& bHeaterOn)
{
    byte data[3];
    humidity=0;
    byte sensorStatus;

    if(!readReg(TRIGGER_HUMD_MEASURE_HOLD, data,sizeof(data)))
    {
        return false;
    }
    if(!isCrcOk(data,2,data[2]))
    {
        return false;
    }
    unsigned int rawHumidity = ((unsigned int) data[0] << 8) | (unsigned int) data[1];
    sensorStatus = rawHumidity & 0x0003; //Grab only the right two bits
    if(sensorStatus!=2)
    {
        return false;
    }
    rawHumidity &= 0xFFFC; //Zero out the status bits but keep them in place

    //Given the raw humidity data, calculate the actual relative humidity
    float tempRH = rawHumidity / (float)65536; //2^16 = 65536
    humidity = -6 + (125 * tempRH);

    if(humidity<0)
    {
        humidity=0;
    }
    if(humidity>100)
    {
        humidity=100;
    }
    //Possible condensation on sensor, enable internal heater to drive condensation off
    //While heater is on, measurement data is invalid
//    bHeaterOn= humidity==0 || humidity>=80;
//    setHeater(bHeaterOn);
    bHeaterOn=false;
    return true;
}

//Read the temperature
/*******************************************************************************************/
//Calc temperature and return it to the user
bool HTU21D::readTemperature(float& temp)
{
    byte data[3];
    temp=0;

    if(!readReg(TRIGGER_TEMP_MEASURE_HOLD, data,sizeof(data)))
    {
        return false;
    }
    if(!isCrcOk(data,2,data[2]))
    {
        return false;
    }
    unsigned int rawTemperature = ((unsigned int) data[0] << 8) | (unsigned int) data[1];

    //sensorStatus = rawTemperature & 0x0003; //Grab only the right two bits
    rawTemperature &= 0xFFFC; //Zero out the status bits but keep them in place

    //Given the raw temperature data, calculate the actual temperature
    float tempTemperature = rawTemperature / (float)65536; //2^16 = 65536
    temp = -46.85 + (175.72 * tempTemperature);
    return true;
}

//Set sensor resolution
/*******************************************************************************************/
bool HTU21D::init(RESOLUTION res)
{
    byte userRegister;

    if((!_pI2c->begin(HTDU21D_ADDRESS)) || (!_pI2c->isPresent()))
    {
        return false;
    }
    if(!readReg(READ_USER_REG, &userRegister,1))
    {
        return false;
    }
    switch(res)
    {
    case RH_8b_TEMP_12b:
        bitSet(userRegister,RES0_BIT);
        bitClear(userRegister, RES1_BIT);
        break;
    case RH_10b_TEMP_13b:
        bitClear(userRegister, RES0_BIT);
        bitSet(userRegister,RES1_BIT);
        break;
    case RH_11b_TEMP_11b:
        bitSet(userRegister, RES0_BIT);
        bitSet(userRegister, RES1_BIT);
        break;
    case RH_12b_TEMP_14b:
        bitClear(userRegister, RES0_BIT);
        bitClear(userRegister, RES1_BIT);
        break;
    default:
        return false;
    }
    return writeCmd(WRITE_USER_REG, &userRegister,1);
}

//sn = SNA3, SNA2, SNA1, SNA0, SNB3, SNB2, SNB1, SNB0
bool HTU21D::readSerialNumber(byte* sn){
    byte yCmd2=SERIAL1_READB;
    byte data[8];
    byte crc=0;

    memset(sn,0,8);
    //read first 4 bytes of serial number
    if(!writeCmd(SERIAL1_READA, &yCmd2,1) || !readReg(data,8))
    {
        return false;
    }
    for(byte i=0;i<4;i++)
    {
        crc=updateCrc(&data[i<<1],1,crc);
        sn[i]=data[i<<1];
    }
    if(crc!=data[7])
    {
        return false;
    }
    yCmd2=SERIAL2_READB;
    //read 2nd 4 bytes of serial number
    if(!writeCmd(SERIAL2_READA, &yCmd2,1) || !readReg(data,6))
    {
        return false;
    }
    crc=updateCrc(&data[0],2,0);
    crc=updateCrc(&data[3],2,crc);
    if(crc!=data[5])
    {
        return false;
    }
    memcpy(&sn[4],&data[0],2);
    memcpy(&sn[6],&data[3],2);
    return true;
}

bool HTU21D::isCrcOk(byte* data, byte nrOfBytes, byte crcRead){
    byte crcCalc=updateCrc(data, nrOfBytes,0);
    return crcCalc==crcRead;
}

//CRC: source: Application Note for I2C Flow and Differential Pressure Sensors CRC Checksum, Sensirion
byte HTU21D::updateCrc (byte *data, byte nbrOfBytes, byte crcIn)
{
    const word POLYNOMIAL=0x131; //P(x)=x^8+x^5+x^4+1 = 100110001
    for (byte byteCtr = 0; byteCtr < nbrOfBytes; ++byteCtr)
    {
        crcIn ^= (data[byteCtr]);
        for (byte bit = 8; bit > 0; --bit)
        { if (crcIn & 0x80) crcIn = (crcIn << 1) ^ POLYNOMIAL;
            else crcIn = (crcIn << 1);
        }
    }
    return crcIn;
}

bool HTU21D::writeCmd(sensorCommands cmd)
{
    return _pI2c->writeByte(cmd);
}

bool HTU21D::writeCmd(sensorCommands cmd, byte* data, byte datalen)
{
    byte data1[datalen+1];
    *data1=cmd;
    memcpy(data1+1,data,datalen);
    return _pI2c->writeBytes(data1, datalen+1);
}

bool HTU21D::readReg(byte* data, byte length)
{
    return _pI2c->readBytes(data, length);
}

bool HTU21D::readReg(sensorCommands reg, byte* data, byte length)
{
    if(!writeCmd(reg))
    {
        return false;
    }
    return readReg(data, length);
}

